<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Computations involving regular matrix pencils · MatrixPencils.jl</title><meta name="title" content="Computations involving regular matrix pencils · MatrixPencils.jl"/><meta property="og:title" content="Computations involving regular matrix pencils · MatrixPencils.jl"/><meta property="twitter:title" content="Computations involving regular matrix pencils · MatrixPencils.jl"/><meta name="description" content="Documentation for MatrixPencils.jl."/><meta property="og:description" content="Documentation for MatrixPencils.jl."/><meta property="twitter:description" content="Documentation for MatrixPencils.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">MatrixPencils.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="klftools.html">Manipulation of general linear matrix pencils</a></li><li><a class="tocitem" href="sklftools.html">Manipulation of structured linear matrix pencils</a></li><li><a class="tocitem" href="klfapps.html">Some applications of matrix pencil computations</a></li><li><a class="tocitem" href="sklfapps.html">Some applications of structured matrix pencil computations</a></li><li class="is-active"><a class="tocitem" href="pregular.html">Computations involving regular matrix pencils</a></li><li><a class="tocitem" href="lstools.html">Manipulation of linearizations of polynomial or rational matrices</a></li><li><a class="tocitem" href="pmtools.html">Manipulation of polynomial matrices</a></li><li><a class="tocitem" href="pmapps.html">Some applications to polynomial matrices</a></li><li><a class="tocitem" href="rmtools.html">Manipulation of rational matrices</a></li><li><a class="tocitem" href="rmapps.html">Some applications to rational matrices</a></li></ul></li><li><span class="tocitem">Internal</span><ul><li><a class="tocitem" href="klftools_int.html">Basic reductions of general and structured linear matrix pencils</a></li></ul></li><li><a class="tocitem" href="makeindex.html">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href="pregular.html">Computations involving regular matrix pencils</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="pregular.html">Computations involving regular matrix pencils</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/andreasvarga/MatrixPencils.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/andreasvarga/MatrixPencils.jl/blob/master/docs/src/pregular.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Computations-involving-regular-matrix-pencils"><a class="docs-heading-anchor" href="#Computations-involving-regular-matrix-pencils">Computations involving regular matrix pencils</a><a id="Computations-involving-regular-matrix-pencils-1"></a><a class="docs-heading-anchor-permalink" href="#Computations-involving-regular-matrix-pencils" title="Permalink"></a></h1><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><strong><a href="pregular.html#MatrixPencils.regbalance!"><code>regbalance!</code></a></strong></td><td style="text-align: left">Balancing regular matrix pencils.</td></tr><tr><td style="text-align: left"><strong><a href="pregular.html#MatrixPencils.isregular"><code>isregular</code></a></strong></td><td style="text-align: left">Checking the regularity of a pencil</td></tr><tr><td style="text-align: left"><strong><a href="pregular.html#MatrixPencils.isunimodular"><code>isunimodular</code></a></strong></td><td style="text-align: left">Checking the unimodularity of a pencil</td></tr><tr><td style="text-align: left"><strong><a href="pregular.html#MatrixPencils.fisplit"><code>fisplit</code></a></strong></td><td style="text-align: left">Finite-infinite eigenvalue splitting</td></tr><tr><td style="text-align: left"><strong><a href="pregular.html#MatrixPencils.sfisplit"><code>sfisplit</code></a></strong></td><td style="text-align: left">Special finite-infinite eigenvalue splitting</td></tr><tr><td style="text-align: left"><strong><a href="pregular.html#MatrixPencils.fihess"><code>fihess</code></a></strong></td><td style="text-align: left">Finite-infinite eigenvalue splitting in a generalized Hessenberg form</td></tr><tr><td style="text-align: left"><strong><a href="pregular.html#MatrixPencils.fischur"><code>fischur</code></a></strong></td><td style="text-align: left">Finite-infinite eigenvalue splitting in a generalized Schur form</td></tr><tr><td style="text-align: left"><strong><a href="pregular.html#MatrixPencils.fischursep"><code>fischursep</code></a></strong></td><td style="text-align: left">Finite-infinite eigenvalue splitting in an ordered generalized Schur form</td></tr><tr><td style="text-align: left"><strong><a href="pregular.html#MatrixPencils.sfischursep"><code>sfischursep</code></a></strong></td><td style="text-align: left">Special finite-infinite eigenvalue splitting in an ordered generalized Schur form</td></tr><tr><td style="text-align: left"><strong><a href="pregular.html#MatrixPencils.fiblkdiag"><code>fiblkdiag</code></a></strong></td><td style="text-align: left">Finite-infinite eigenvalue splitting based block diagonalization</td></tr><tr><td style="text-align: left"><strong><a href="pregular.html#MatrixPencils.gsblkdiag"><code>gsblkdiag</code></a></strong></td><td style="text-align: left">Finite-infinite and stable-unstable eigenvalue splitting based block diagonalization</td></tr><tr><td style="text-align: left"><strong><a href="pregular.html#MatrixPencils.ssblkdiag"><code>ssblkdiag</code></a></strong></td><td style="text-align: left">Stable-unstable eigenvalue splitting based block diagonalization</td></tr><tr><td style="text-align: left"><strong><a href="pregular.html#MatrixPencils.saloc"><code>saloc</code></a></strong></td><td style="text-align: left">Spectrum alocation for the pairs <code>(A,B)</code> and <code>(A-λE,B)</code></td></tr><tr><td style="text-align: left"><strong><a href="pregular.html#MatrixPencils.salocd"><code>salocd</code></a></strong></td><td style="text-align: left">Spectrum alocation for the dual pairs <code>(A,C)</code> and <code>(A-λE,C)</code></td></tr><tr><td style="text-align: left"><strong><a href="pregular.html#MatrixPencils.salocinf"><code>salocinf</code></a></strong></td><td style="text-align: left">Infinite spectrum alocation for the pair <code>(A-λE,B)</code></td></tr><tr><td style="text-align: left"><strong><a href="pregular.html#MatrixPencils.salocinfd"><code>salocinfd</code></a></strong></td><td style="text-align: left">Infinite spectrum alocation for the dual pair <code>(A-λE,C)</code></td></tr><tr><td style="text-align: left"><strong><a href="pregular.html#MatrixPencils.ordeigvals"><code>ordeigvals</code></a></strong></td><td style="text-align: left">Order-preserving computation of eigenvalues of a Schur matrix or a generalized Schur pair.</td></tr></table><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixPencils.regbalance!" href="#MatrixPencils.regbalance!"><code>MatrixPencils.regbalance!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> regbalance!(A, E; maxiter = 100, tol = 1, pow2 = true) -&gt; (Dl,Dr)</code></pre><p>Balance the regular pair <code>(A,E)</code> by reducing the 1-norm of the matrix <code>M := abs(A)+abs(E)</code> by row and column balancing.  This involves diagonal similarity transformations <code>Dl*(A-λE)*Dr</code> applied iteratively to <code>M</code> to make the rows and columns of <code>Dl*M*Dr</code> as close in norm as possible. The <a href="https://en.wikipedia.org/wiki/Sinkhorn%27s_theorem">Sinkhorn–Knopp algorithm</a> is used  to reduce <code>M</code> to a doubly stochastic matrix. </p><p>The resulting <code>Dl</code> and <code>Dr</code> are diagonal scaling matrices.   If the keyword argument <code>pow2 = true</code> is specified, then the components of the resulting  optimal <code>Dl</code> and <code>Dr</code> are replaced by their nearest integer powers of 2.  If <code>pow2 = false</code>, the optimal values <code>Dl</code> and <code>Dr</code> are returned. The resulting <code>Dl*A*Dr</code> and <code>Dl*E*Dr</code> overwrite <code>A</code> and <code>E</code>, respectively</p><p>The keyword argument <code>tol = τ</code>, with <code>τ ≤ 1</code>,  specifies the tolerance used in the stopping criterion.  The iterative process is stopped as soon as the incremental scalings are <code>tol</code>-close to the identity. </p><p>The keyword argument <code>maxiter = k</code> specifies the maximum number of iterations <code>k</code>  allowed in the balancing algorithm. </p><p><em>Note:</em> This function is based on the MATLAB function <code>rowcolsums.m</code> of [1], modified such that the scaling operations are directly applied to <code>A</code> and <code>E</code>.  </p><p>[1] F.M.Dopico, M.C.Quintana and P. van Dooren,      &quot;Diagonal scalings for the eigenstructure of arbitrary pencils&quot;, SIMAX, 43:1213-1237, 2022. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixPencils.jl/blob/315e583cb9aa132ee009c727c1e0948d67c74156/src/regtools.jl#L899-L926">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixPencils.ordeigvals" href="#MatrixPencils.ordeigvals"><code>MatrixPencils.ordeigvals</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> ev = ordeigvals(A)</code></pre><p>Compute the vector <code>ev</code> of eigenvalues of a Schur matrix <code>A</code> in their order of appearance down the diagonal of <code>A</code>. <code>ordeigvals</code> is an order-preserving version of <code>eigvals</code> for triangular/quasitriangular matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixPencils.jl/blob/315e583cb9aa132ee009c727c1e0948d67c74156/src/gsfstab.jl#L1017-L1022">source</a></section><section><div><pre><code class="language-julia hljs">ordeigvals(A, B) -&gt; (ev, α, β)</code></pre><p>Compute the vector <code>ev</code> of generalized eigenvalues of the pair <code>(A,B)</code>, with <code>A</code> a Schur matrix and <code>B</code> an upper triangular matrix,  in their order of appearance down the diagonals of <code>A</code> and <code>B</code>. <code>ordeigvals</code> is an order-preserving version of <code>eigvals</code> for (triangular/quasi-upper-triangular, triangular) pairs of matrices. <code>α</code> is a complex vector and <code>β</code> is a real vector such that the generalized eigenvalues <code>ev</code> can be alternatively obtained with <code>α./β</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixPencils.jl/blob/315e583cb9aa132ee009c727c1e0948d67c74156/src/gsfstab.jl#L1138-L1145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixPencils.isregular" href="#MatrixPencils.isregular"><code>MatrixPencils.isregular</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isregular(A, E, γ; atol::Real = 0,  rtol::Real = atol &gt; 0 ? 0 : n*ϵ) -&gt; Bool</code></pre><p>Test whether the matrix pencil <code>A-λE</code> is regular at <code>λ = γ</code> (i.e., <code>A-λE</code> is square and <span>${\small\det(A-λE) \neq 0}$</span>).  The underlying computational procedure checks the maximal rank of <code>A-γE</code> if <code>γ</code> is finite and of <code>E</code> if  <code>γ</code> is infinite . </p><p>The keyword arguements <code>atol</code> and <code>rtol</code> specify the absolute and relative tolerances for the nonzero elements of <code>A-γE</code>, respectively.  The default relative tolerance is <code>n*ϵ</code>, where <code>n</code> is the size of  <code>A</code>, and <code>ϵ</code> is the  machine epsilon of the element type of <code>A</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixPencils.jl/blob/315e583cb9aa132ee009c727c1e0948d67c74156/src/regtools.jl#L202-L213">source</a></section><section><div><pre><code class="language-julia hljs">isregular(A, E; atol1::Real = 0, atol2::Real = 0, rtol::Real=min(atol1,atol2)&gt;0 ? 0 : n*ϵ) -&gt; Bool</code></pre><p>Test whether the matrix pencil <code>A-λE</code> is regular (i.e., <code>A-λE</code> is square and <span>${\small\det(A-λE) \not\equiv 0}$</span>).  The underlying computational procedure reduces the pencil <code>A-λE</code> to an appropriate Kronecker-like form,  which provides information on the rank of <code>A-λE</code>. </p><p>The keyword arguements <code>atol1</code>, <code>atol2</code> and <code>rtol</code> specify the absolute tolerance for the nonzero elements of <code>A</code>, the absolute tolerance for the nonzero elements of <code>E</code>, and the relative tolerance  for the nonzero elements of <code>A</code> and <code>E</code>, respectively.  The default relative tolerance is <code>n*ϵ</code>, where <code>n</code> is the size of  <code>A</code>, and <code>ϵ</code> is the  machine epsilon of the element type of <code>A</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixPencils.jl/blob/315e583cb9aa132ee009c727c1e0948d67c74156/src/regtools.jl#L227-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixPencils.isunimodular" href="#MatrixPencils.isunimodular"><code>MatrixPencils.isunimodular</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isunimodular(A, E; atol1::Real = 0, atol2::Real = 0, rtol::Real=min(atol1,atol2)&gt;0 ? 0 : n*ϵ) -&gt; Bool</code></pre><p>Test whether the matrix pencil <code>A-λE</code> is unimodular (i.e., <code>A-λE</code> is square, regular and <code>det(A-λE) == constant</code>).  The underlying computational procedure reduces the pencil <code>A-λE</code> to an appropriate Kronecker-like form,  which provides information to check the full rank of <code>A-λE</code> and the lack of finite eigenvalues. </p><p>The keyword arguements <code>atol1</code>, <code>atol2</code> and <code>rtol</code> specify the absolute tolerance for the nonzero elements of <code>A</code>, the absolute tolerance for the nonzero elements of <code>E</code>, and the relative tolerance  for the nonzero elements of <code>A</code> and <code>E</code>, respectively.  The default relative tolerance is <code>n*ϵ</code>, where <code>n</code> is the size of  <code>A</code>, and <code>ϵ</code> is the  machine epsilon of the element type of <code>A</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixPencils.jl/blob/315e583cb9aa132ee009c727c1e0948d67c74156/src/regtools.jl#L270-L282">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixPencils.fisplit" href="#MatrixPencils.fisplit"><code>MatrixPencils.fisplit</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fisplit(A, E, B, C; fast = true, finite_infinite = false, atol1 = 0, atol2 = 0, rtol, withQ = true, withZ = true) -&gt; (At, Et, Bt, Ct, Q, Z, ν, blkdims)</code></pre><p>Reduce the regular matrix pencil <code>A - λE</code> to an equivalent form <code>At - λEt = Q&#39;*(A - λE)*Z</code> using  orthogonal or unitary transformation matrices <code>Q</code> and <code>Z</code> such that the transformed matrices <code>At</code> and <code>Et</code> are in one of the following block upper-triangular forms:</p><p>(1) if <code>finite_infinite = false</code>, then</p><pre><code class="nohighlight hljs">               | Ai-λEi |   *     |
    At - λEt = |--------|---------|, 
               |    O   | Af-λEf  |</code></pre><p>where the <code>ni x ni</code> subpencil <code>Ai-λEi</code> contains the infinite elementary  divisors and the <code>nf x nf</code> subpencil <code>Af-λEf</code>, with <code>Ef</code> nonsingular and upper triangular, contains the finite eigenvalues of the pencil <code>A-λE</code>.</p><p>The subpencil <code>Ai-λEi</code> is in a staircase form, with <code>Ai</code> nonsingular and upper triangular and <code>Ei</code> nilpotent and upper triangular.  The <code>nb</code>-dimensional vector <code>ν</code> contains the dimensions of the diagonal blocks of the staircase form  <code>Ai-λEi</code> such that <code>i</code>-th block has dimensions <code>ν[i] x ν[i]</code>.  The difference <code>ν[i]-ν[i+1]</code> for <code>i = 1, 2, ..., nb</code> is the number of infinite elementary divisors of degree <code>i</code>  (with <code>ν[nb+1] = 0</code>).</p><p>The dimensions of the diagonal blocks are returned in <code>blkdims = (ni, nf)</code>.   </p><p>(2) if <code>finite_infinite = true</code>, then</p><pre><code class="nohighlight hljs">               | Af-λEf |   *    |
    At - λEt = |--------|--------|, 
               |   O    | Ai-λEi |</code></pre><p>where the <code>nf x nf</code> subpencil <code>Af-λEf</code>, with <code>Ef</code> nonsingular and upper triangular,  contains the finite eigenvalues of the pencil <code>A-λE</code> and the <code>ni x ni</code> subpencil <code>Ai-λEi</code>  contains the infinite elementary divisors.</p><p>The subpencil <code>Ai-λEi</code> is in a staircase form, with <code>Ai</code> nonsingular and upper triangular  and <code>Ei</code> nilpotent and upper triangular.  The <code>nb</code>-dimensional vectors <code>ν</code> contains the dimensions of the diagonal blocks of the staircase form <code>Ai-λEi</code> such that <code>i</code>-th block has dimensions <code>ν[i] x ν[i]</code>.  The difference <code>ν[nb-j+1]-ν[nb-j]</code> for <code>j = 1, 2, ..., nb</code> is the number of infinite elementary  divisors of degree <code>j</code> (with <code>ν[0] = 0</code>).</p><p>The dimensions of the diagonal blocks are returned in <code>blkdims = (nf, ni)</code>.   </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively, the absolute tolerance for the  nonzero elements of <code>A</code>, the absolute tolerance for the nonzero elements of <code>E</code>,  and the relative tolerance  for the nonzero elements of <code>A</code> and <code>E</code>. </p><p>The reduction is performed using rank decisions based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.</p><p>The performed left orthogonal or unitary transformations are accumulated in the matrix <code>Q</code> if <code>withQ = true</code>.  Otherwise, <code>Q</code> is set to <code>nothing</code>.    The performed right orthogonal or unitary transformations are accumulated in the matrix <code>Z</code> if <code>withZ = true</code>.  Otherwise, <code>Z</code> is set to <code>nothing</code>.  </p><p><code>Bt = Q&#39;*B</code>, unless <code>B = missing</code>, in which case <code>Bt = missing</code> is returned, and <code>Ct = C*Z</code>,  unless <code>C = missing</code>, in which case <code>Ct = missing</code> is returned .              </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixPencils.jl/blob/315e583cb9aa132ee009c727c1e0948d67c74156/src/regtools.jl#L315-L372">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixPencils.fisplit!" href="#MatrixPencils.fisplit!"><code>MatrixPencils.fisplit!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fisplit!(A, E, Q, Z, B, C; fast = true, finite_infinite = false, atol1 = 0, atol2 = 0, rtol, withQ = true, withZ = true) -&gt; (ν, blkdims)</code></pre><p>Reduce the regular matrix pencil <code>A - λE</code> to an equivalent form <code>At - λEt = Q1&#39;*(A - λE)*Z1</code> using  orthogonal or unitary transformation matrices <code>Q1</code> and <code>Z1</code> such that the transformed matrices <code>At</code> and <code>Et</code> are in one of the following block upper-triangular forms:</p><p>(1) if <code>finite_infinite = false</code>, then</p><pre><code class="nohighlight hljs">               | Ai-λEi |   *     |
    At - λEt = |--------|---------|, 
               |    O   | Af-λEf  |</code></pre><p>where the <code>ni x ni</code> subpencil <code>Ai-λEi</code> contains the infinite elementary  divisors and the <code>nf x nf</code> subpencil <code>Af-λEf</code>, with <code>Ef</code> nonsingular and upper triangular, contains the finite eigenvalues of the pencil <code>A-λE</code>.</p><p>The subpencil <code>Ai-λEi</code> is in a staircase form, with <code>Ai</code> nonsingular and upper triangular and <code>Ei</code> nilpotent and upper triangular.  The <code>nb</code>-dimensional vector <code>ν</code> contains the dimensions of the diagonal blocks of the staircase form  <code>Ai-λEi</code> such that <code>i</code>-th block has dimensions <code>ν[i] x ν[i]</code>.  The difference <code>ν[i]-ν[i+1]</code> for <code>i = 1, 2, ..., nb</code> is the number of infinite elementary divisors of degree <code>i</code>  (with <code>ν[nb+1] = 0</code>).</p><p>The dimensions of the diagonal blocks are returned in <code>blkdims = (ni, nf)</code>.   </p><p>(2) if <code>finite_infinite = true</code>, then</p><pre><code class="nohighlight hljs">               | Af-λEf |   *    |
    At - λEt = |--------|--------|, 
               |   O    | Ai-λEi |</code></pre><p>where the <code>nf x nf</code> subpencil <code>Af-λEf</code>, with <code>Ef</code> nonsingular and upper triangular,  contains the finite eigenvalues of the pencil <code>A-λE</code> and the <code>ni x ni</code> subpencil <code>Ai-λEi</code>  contains the infinite elementary divisors.</p><p>The subpencil <code>Ai-λEi</code> is in a staircase form, with <code>Ai</code> nonsingular and upper triangular and <code>Ei</code> nilpotent and upper triangular.  The <code>nb</code>-dimensional vectors <code>ν</code> contains the dimensions of the diagonal blocks of the staircase form <code>Ai-λEi</code> such that <code>i</code>-th block has dimensions <code>ν[i] x ν[i]</code>.  The difference <code>ν[nb-j+1]-ν[nb-j]</code> for <code>j = 1, 2, ..., nb</code> is the number of infinite elementary  divisors of degree <code>j</code> (with <code>ν[0] = 0</code>).</p><p>The dimensions of the diagonal blocks are returned in <code>blkdims = (nf, ni)</code>.   </p><p>The reduced matrices <code>At</code> and <code>Et</code> are returned in <code>A</code> and <code>E</code>, respectively,  while <code>Q1&#39;*B</code> is returned in <code>B</code>, unless <code>B = missing</code>, and <code>C*Z1</code>, is returned in <code>C</code>,  unless <code>C = missing</code>.   </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively, the absolute tolerance for the  nonzero elements of <code>A</code>, the absolute tolerance for the nonzero elements of <code>E</code>,  and the relative tolerance  for the nonzero elements of <code>A</code> and <code>E</code>. </p><p>The reduction is performed using rank decisions based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.</p><p>The performed left orthogonal or unitary transformations Q1 are accumulated in the matrix <code>Q &lt;- Q*Q1</code>  if <code>withQ = true</code>. Otherwise, <code>Q</code> is unchanged.    The performed right orthogonal or unitary transformations Z1 are accumulated in the matrix <code>Z &lt;- Z*Z1</code>  if <code>withZ = true</code>. Otherwise, <code>Z</code> is unchanged.            </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixPencils.jl/blob/315e583cb9aa132ee009c727c1e0948d67c74156/src/regtools.jl#L404-L462">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixPencils.sfisplit" href="#MatrixPencils.sfisplit"><code>MatrixPencils.sfisplit</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sfisplit(A, E, B, C; fast = true, finite_infinite = false, atol1 = 0, atol2 = 0, rtol, withQ = true, withZ = true) -&gt; (At, Et, Bt, Ct, Q, Z, ν, blkdims)</code></pre><p>Reduce the regular matrix pencil <code>A - λE</code> to an equivalent form <code>At - λEt = Q&#39;*(A - λE)*Z</code> using  orthogonal or unitary transformation matrices <code>Q</code> and <code>Z</code> such that the transformed matrices <code>At</code> and <code>Et</code> are in one of the following block upper-triangular forms:</p><p>(1) if <code>finite_infinite = true</code>, then</p><pre><code class="nohighlight hljs">               | Ai1    *        *     |
    At - λEt = | O    Af-λEf     *     |
               | O      0     Ai2-λEi2 |</code></pre><p>where the <code>ni1 x ni1</code> upper triangular nonsingular matrix <code>Ai1</code> and the <code>ni2 x ni2</code> subpencil <code>Ai2-λEi2</code> contain the infinite elementary  divisors and the <code>nf x nf</code> subpencil <code>Af-λEf</code>, with <code>Ef</code> nonsingular and upper triangular, contains the finite eigenvalues of the pencil <code>A-λE</code>.</p><p>The subpencil <code>Ai2-λEi2</code> is in a staircase form, with <code>Ai2</code> nonsingular and upper triangular and <code>Ei2</code> nilpotent and upper triangular.  The <code>nb</code>-dimensional vector <code>ν</code> contains the dimensions of the diagonal blocks of the staircase form  <code>Ai2-λEi2</code> such that <code>i</code>-th block has dimensions <code>ν[i] x ν[i]</code>.  The difference <code>ν[nb-j+2]-ν[nb-j+1]</code> for <code>j = 1, 2, ..., nb+1</code> is the number of infinite elementary  divisors of degree <code>j</code> (with <code>ν[0] := 0</code> and <code>ν[nb+1] := ni1</code>).</p><p>The dimensions of the diagonal blocks are returned in <code>blkdims = (ni1, nf, ni2)</code>.   </p><p>(2) if <code>finite_infinite = false</code>, then</p><pre><code class="nohighlight hljs">               | Ai1-λEi1    *      *  |
    At - λEt = | O         Af-λEf   *  |
               | O           0     Ai2 |</code></pre><p>where the <code>ni1 x ni1</code> subpencil <code>Ai1-λEi1</code> and the upper triangular nonsingular matrix <code>Ai2</code> contain the infinite elementary  divisors and the <code>nf x nf</code> subpencil <code>Af-λEf</code>, with <code>Ef</code> nonsingular and upper triangular, contains the finite eigenvalues of the pencil <code>A-λE</code>.</p><p>The subpencil <code>Ai1-λEi1</code> is in a staircase form, with <code>Ai1</code> nonsingular and upper triangular and <code>Ei1</code> nilpotent and upper triangular.  The <code>nb</code>-dimensional vectors <code>ν</code> contains the dimensions of the diagonal blocks of the staircase form <code>Ai1-λEi1</code> such that <code>i</code>-th block has dimensions <code>ν[i] x ν[i]</code>.  The difference <code>ν[i]-ν[i+1]</code> for <code>i = 0, 1, 2, ..., nb</code> is the number of infinite elementary divisors of degree <code>i</code>  (with <code>ν[nb+1] = 0</code> and <code>ν[0] = ni2</code>).</p><p>The dimensions of the diagonal blocks are returned in <code>blkdims = (ni1, nf, ni2)</code>.   </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively, the absolute tolerance for the  nonzero elements of <code>A</code>, the absolute tolerance for the nonzero elements of <code>E</code>,  and the relative tolerance  for the nonzero elements of <code>A</code> and <code>E</code>. </p><p>The reduction is performed using rank decisions based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.</p><p>The performed left orthogonal or unitary transformations are accumulated in the matrix <code>Q</code> if <code>withQ = true</code>.  Otherwise, <code>Q</code> is set to <code>nothing</code>.    The performed right orthogonal or unitary transformations are accumulated in the matrix <code>Z</code> if <code>withZ = true</code>.  Otherwise, <code>Z</code> is set to <code>nothing</code>.  </p><p><code>Bt = Q&#39;*B</code>, unless <code>B = missing</code>, in which case <code>Bt = missing</code> is returned, and <code>Ct = C*Z</code>,  unless <code>C = missing</code>, in which case <code>Ct = missing</code> is returned .              </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixPencils.jl/blob/315e583cb9aa132ee009c727c1e0948d67c74156/src/regtools.jl#L576-L631">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixPencils.sfisplit!" href="#MatrixPencils.sfisplit!"><code>MatrixPencils.sfisplit!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sfisplit!(A, E, Q, Z, B, C; fast = true, finite_infinite = false, atol1 = 0, atol2 = 0, rtol, withQ = true, withZ = true) -&gt; (ν, blkdims)</code></pre><p>Reduce the regular matrix pencil <code>A - λE</code> to an equivalent form <code>At - λEt = Q1&#39;*(A - λE)*Z1</code> using  orthogonal or unitary transformation matrices <code>Q1</code> and <code>Z1</code> such that the transformed matrices <code>At</code> and <code>Et</code> are in one of the following block upper-triangular forms:</p><p>(1) if <code>finite_infinite = true</code>, then</p><pre><code class="nohighlight hljs">               | Ai1    *        *     |
    At - λEt = | O    Af-λEf     *     |
               | O      0     Ai2-λEi2 |</code></pre><p>where the <code>ni1 x ni1</code> upper triangular nonsingular matrix <code>Ai1</code> and the <code>ni2 x ni2</code> subpencil <code>Ai2-λEi2</code> contain the infinite elementary  divisors and the <code>nf x nf</code> subpencil <code>Af-λEf</code>, with <code>Ef</code> nonsingular and upper triangular, contains the finite eigenvalues of the pencil <code>A-λE</code>.</p><p>The subpencil <code>Ai2-λEi2</code> is in a staircase form, with <code>Ai2</code> nonsingular and upper triangular and <code>Ei2</code> nilpotent and upper triangular.  The <code>nb</code>-dimensional vector <code>ν</code> contains the dimensions of the diagonal blocks of the staircase form  <code>Ai2-λEi2</code> such that <code>i</code>-th block has dimensions <code>ν[i] x ν[i]</code>.  The difference <code>ν[nb-j+2]-ν[nb-j+1]</code> for <code>j = 1, 2, ..., nb+1</code> is the number of infinite elementary  divisors of degree <code>j</code> (with <code>ν[0] := 0</code> and <code>ν[nb+1] := ni1</code>).</p><p>The dimensions of the diagonal blocks are returned in <code>blkdims = (ni1, nf, ni2)</code>.   </p><p>(2) if <code>finite_infinite = false</code>, then</p><pre><code class="nohighlight hljs">               | Ai1-λEi1    *      *  |
    At - λEt = | O         Af-λEf   *  |
               | O           0     Ai2 |</code></pre><p>where the <code>ni1 x ni1</code> subpencil <code>Ai1-λEi1</code> and the upper triangular nonsingular matrix <code>Ai2</code> contain the infinite elementary  divisors and the <code>nf x nf</code> subpencil <code>Af-λEf</code>, with <code>Ef</code> nonsingular and upper triangular, contains the finite eigenvalues of the pencil <code>A-λE</code>.</p><p>The subpencil <code>Ai1-λEi1</code> is in a staircase form, with <code>Ai1</code> nonsingular and upper triangular and <code>Ei1</code> nilpotent and upper triangular.  The <code>nb</code>-dimensional vectors <code>ν</code> contains the dimensions of the diagonal blocks of the staircase form <code>Ai1-λEi1</code> such that <code>i</code>-th block has dimensions <code>ν[i] x ν[i]</code>.  The difference <code>ν[i]-ν[i+1]</code> for <code>i = 0, 1, 2, ..., nb</code> is the number of infinite elementary divisors of degree <code>i</code>  (with <code>ν[nb+1] = 0</code> and <code>ν[0] = ni2</code>).</p><p>The dimensions of the diagonal blocks are returned in <code>blkdims = (ni1, nf, ni2)</code>.   </p><p>The reduced matrices <code>At</code> and <code>Et</code> are returned in <code>A</code> and <code>E</code>, respectively,  while <code>Q1&#39;*B</code> is returned in <code>B</code>, unless <code>B = missing</code>, and <code>C*Z1</code>, is returned in <code>C</code>,  unless <code>C = missing</code>.   </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively, the absolute tolerance for the  nonzero elements of <code>A</code>, the absolute tolerance for the nonzero elements of <code>E</code>,  and the relative tolerance  for the nonzero elements of <code>A</code> and <code>E</code>. </p><p>The reduction is performed using rank decisions based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.</p><p>The performed left orthogonal or unitary transformations Q1 are accumulated in the matrix <code>Q &lt;- Q*Q1</code>  if <code>withQ = true</code>. Otherwise, <code>Q</code> is unchanged.    The performed right orthogonal or unitary transformations Z1 are accumulated in the matrix <code>Z &lt;- Z*Z1</code>  if <code>withZ = true</code>. Otherwise, <code>Z</code> is unchanged.            </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixPencils.jl/blob/315e583cb9aa132ee009c727c1e0948d67c74156/src/regtools.jl#L663-L719">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixPencils.fihess" href="#MatrixPencils.fihess"><code>MatrixPencils.fihess</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fihess(A, E; fast = true, finite_infinite = false, atol1 = 0, atol2 = 0, rtol, withQ = true, withZ = true) -&gt; (At, Et, Q, Z, ν, blkdims)</code></pre><p>Reduce the regular matrix pencil <code>A - λE</code> to an equivalent form <code>At - λEt = Q&#39;*(A - λE)*Z</code> using  orthogonal or unitary transformation matrices <code>Q</code> and <code>Z</code> such that the transformed matrices <code>At</code> and <code>Et</code> are in one of the following block upper-triangular forms:</p><p>(1) if <code>finite_infinite = false</code>, then</p><pre><code class="nohighlight hljs">               | Ai-λEi |   *     |
    At - λEt = |--------|---------|, 
               |    O   | Af-λEf  |</code></pre><p>where the <code>ni x ni</code> subpencil <code>Ai-λEi</code> contains the infinite elementary divisors and  the <code>nf x nf</code> subpencil <code>Af-λEf</code> contains the finite eigenvalues of the pencil <code>A-λE</code>.</p><p>The subpencil <code>Ai-λEi</code> is in a staircase form, with <code>Ai</code> nonsingular and upper triangular and <code>Ei</code> nilpotent and upper triangular.  The <code>nb</code>-dimensional vector <code>ν</code> contains the dimensions of the diagonal blocks of the staircase form  <code>Ai-λEi</code> such that <code>i</code>-th block has dimensions <code>ν[i] x ν[i]</code>.  The difference <code>ν[i]-ν[i+1]</code> for <code>i = 1, 2, ..., nb</code> is the number of infinite elementary divisors of degree <code>i</code>  (with <code>ν[nb+1] = 0</code>).</p><p>The subpencil <code>Af-λEf</code> is with <code>Af</code> in an upper Hessenberg form and <code>Ef</code> nonsingular and upper triangular. </p><p>The dimensions of the diagonal blocks are returned in <code>blkdims = (ni, nf)</code>.   </p><p>(2) if <code>finite_infinite = true</code>, then</p><pre><code class="nohighlight hljs">               | Af-λEf |   *    |
    At - λEt = |--------|--------|, 
               |   O    | Ai-λEi |</code></pre><p>where the <code>nf x nf</code> subpencil <code>Af-λEf</code>, with <code>Ef</code> nonsingular and upper triangular,  contains the finite eigenvalues of the pencil <code>A-λE</code> and the <code>ni x ni</code> subpencil <code>Ai-λEi</code>  contains the infinite elementary divisors.</p><p>The subpencil <code>Af-λEf</code> is with <code>Af</code> in an upper Hessenberg form and <code>Ef</code> nonsingular and upper triangular.  </p><p>The subpencil <code>Ai-λEi</code> is in a staircase form, with <code>Ai</code> nonsingular and upper triangular  and <code>Ei</code> nilpotent and upper triangular.  The <code>nb</code>-dimensional vectors <code>ν</code> contains the dimensions of the diagonal blocks of the staircase form <code>Ai-λEi</code> such that <code>i</code>-th block has dimensions <code>ν[i] x ν[i]</code>.  The difference <code>ν[nb-j+1]-ν[nb-j]</code> for <code>j = 1, 2, ..., nb</code> is the number of infinite elementary  divisors of degree <code>j</code> (with <code>ν[0] = 0</code>).</p><p>The dimensions of the diagonal blocks are returned in <code>blkdims = (nf, ni)</code>.   </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively, the absolute tolerance for the  nonzero elements of <code>A</code>, the absolute tolerance for the nonzero elements of <code>E</code>,  and the relative tolerance  for the nonzero elements of <code>A</code> and <code>E</code>. </p><p>The reduction is performed using rank decisions based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.</p><p>The performed left orthogonal or unitary transformations are accumulated in the matrix <code>Q</code> if <code>withQ = true</code>.  Otherwise, <code>Q</code> is set to <code>nothing</code>.    The performed right orthogonal or unitary transformations are accumulated in the matrix <code>Z</code> if <code>withZ = true</code>.  Otherwise, <code>Z</code> is set to <code>nothing</code>.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixPencils.jl/blob/315e583cb9aa132ee009c727c1e0948d67c74156/src/gsep.jl#L1-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixPencils.fischur" href="#MatrixPencils.fischur"><code>MatrixPencils.fischur</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fischur(A, E; fast = true, finite_infinite = false, atol1 = 0, atol2 = 0, rtol, withQ = true, withZ = true) -&gt; (At, Et, Q, Z, ν, blkdims)</code></pre><p>Reduce the regular matrix pencil <code>A - λE</code> to an equivalent form <code>At - λEt = Q&#39;*(A - λE)*Z</code> using  orthogonal or unitary transformation matrices <code>Q</code> and <code>Z</code> such that the transformed matrices <code>At</code> and <code>Et</code> are in one of the following block upper-triangular forms:</p><p>(1) if <code>finite_infinite = false</code>, then</p><pre><code class="nohighlight hljs">               | Ai-λEi |   *     |
    At - λEt = |--------|---------|, 
               |    O   | Af-λEf  |</code></pre><p>where the <code>ni x ni</code> subpencil <code>Ai-λEi</code> contains the infinite elementary divisors and  the <code>nf x nf</code> subpencil <code>Af-λEf</code> contains the finite eigenvalues of the pencil <code>A-λE</code>.</p><p>The subpencil <code>Ai-λEi</code> is in a staircase form, with <code>Ai</code> nonsingular and upper triangular and <code>Ei</code> nilpotent and upper triangular.  The <code>nb</code>-dimensional vector <code>ν</code> contains the dimensions of the diagonal blocks of the staircase form  <code>Ai-λEi</code> such that <code>i</code>-th block has dimensions <code>ν[i] x ν[i]</code>.  The difference <code>ν[i]-ν[i+1]</code> for <code>i = 1, 2, ..., nb</code> is the number of infinite elementary divisors of degree <code>i</code>  (with <code>ν[nb+1] = 0</code>).</p><p>The subpencil <code>Af-λEf</code> is with the pair <code>(Af,Ef)</code> in a generalized Schur form, with <code>Af</code> (quasi) upper triangular and  <code>Ef</code> nonsingular and upper triangular.  </p><p>The dimensions of the diagonal blocks are returned in <code>blkdims = (ni, nf)</code>.   </p><p>(2) if <code>finite_infinite = true</code>, then</p><pre><code class="nohighlight hljs">               | Af-λEf |   *    |
    At - λEt = |--------|--------|, 
               |   O    | Ai-λEi |</code></pre><p>where the <code>nf x nf</code> subpencil <code>Af-λEf</code>, with <code>Ef</code> nonsingular and upper triangular,  contains the finite eigenvalues of the pencil <code>A-λE</code> and the <code>ni x ni</code> subpencil <code>Ai-λEi</code>  contains the infinite elementary divisors.</p><p>The subpencil <code>Af-λEf</code> is with the pair <code>(Af,Ef)</code> in a generalized Schur form, with <code>Af</code> (quasi) upper triangular and  <code>Ef</code> nonsingular and upper triangular.  </p><p>The subpencil <code>Ai-λEi</code> is in a staircase form, with <code>Ai</code> nonsingular and upper triangular  and <code>Ei</code> nilpotent and upper triangular.  The <code>nb</code>-dimensional vectors <code>ν</code> contains the dimensions of the diagonal blocks of the staircase form <code>Ai-λEi</code> such that <code>i</code>-th block has dimensions <code>ν[i] x ν[i]</code>.  The difference <code>ν[nb-j+1]-ν[nb-j]</code> for <code>j = 1, 2, ..., nb</code> is the number of infinite elementary  divisors of degree <code>j</code> (with <code>ν[0] = 0</code>).</p><p>The dimensions of the diagonal blocks are returned in <code>blkdims = (nf, ni)</code>.   </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively, the absolute tolerance for the  nonzero elements of <code>A</code>, the absolute tolerance for the nonzero elements of <code>E</code>,  and the relative tolerance  for the nonzero elements of <code>A</code> and <code>E</code>. </p><p>The reduction is performed using rank decisions based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.</p><p>The performed left orthogonal or unitary transformations are accumulated in the matrix <code>Q</code> if <code>withQ = true</code>.  Otherwise, <code>Q</code> is set to <code>nothing</code>.    The performed right orthogonal or unitary transformations are accumulated in the matrix <code>Z</code> if <code>withZ = true</code>.  Otherwise, <code>Z</code> is set to <code>nothing</code>.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixPencils.jl/blob/315e583cb9aa132ee009c727c1e0948d67c74156/src/gsep.jl#L84-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixPencils.fischursep" href="#MatrixPencils.fischursep"><code>MatrixPencils.fischursep</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fischursep(A, E; smarg, disc = false, fast = true, finite_infinite = false, stable_unstable = false, atol1 = 0, atol2 = 0, rtol, withQ = true, withZ = true) -&gt; (At, Et, Q, Z, ν, blkdims)</code></pre><p>Reduce the regular matrix pencil <code>A - λE</code> to an equivalent block upper triangular form <code>At - λEt = Q&#39;*(A - λE)*Z</code>  using orthogonal or unitary transformation matrices <code>Q</code> and <code>Z</code> such that the transformed matrices <code>At</code> and <code>Et</code>  have separated infinite, stable and unstable eigenvalues with respect to a stability domain <code>Cs</code> defined by the stability margin parameter <code>smarg</code> and  the stability type parameter <code>disc</code>. If <code>disc = false</code>, <code>Cs</code> is the set of complex numbers with real parts less than <code>smarg</code>,  while if <code>disc = true</code>, <code>Cs</code> is the set of complex numbers with moduli less than <code>smarg</code> (i.e., the interior of a disc  of radius <code>smarg</code> centered in the origin). If <code>smarg = missing</code>, the default value used is <code>smarg = 0</code>, if  <code>disc = false</code>, and <code>smarg = 1</code>, if <code>disc = true</code>.</p><p>The pencil <code>At - λEt</code> results in one of the following block upper-triangular forms:</p><p>(1) if <code>finite_infinite = false</code>, then</p><pre><code class="nohighlight hljs">               | Ai-λEi   *      *    |
    At - λEt = |    O   A1-λE1   *    |
               |    0     0    A2-λE2 |</code></pre><p>where the <code>ni x ni</code> subpencil <code>Ai-λEi</code> contains the infinite elementary divisors,  the <code>n1 x n1</code> subpencil <code>A1-λE1</code> is with the pair <code>(A1,E1)</code> in a generalized Schur form, and the  <code>n2 x n2</code> subpencil <code>A2-λE2</code> is with the pair <code>(A2,E2)</code> in a generalized Schur form.  The pencil <code>A1-λE1</code> has unstable finite eigenvalues and <code>A2-λE2</code> has stable finite eigenvalues if <code>stable_unstable = false</code>, while <code>A1-λE1</code> has stable finite eigenvalues and <code>A2-λE2</code> has unstable finite eigenvalues if <code>stable_unstable = true</code>.</p><p>The subpencil <code>Ai-λEi</code> is in a staircase form, with <code>Ai</code> nonsingular and upper triangular and <code>Ei</code> nilpotent and upper triangular.  The <code>nb</code>-dimensional vector <code>ν</code> contains the dimensions of the diagonal blocks of the staircase form  <code>Ai-λEi</code> such that <code>i</code>-th block has dimensions <code>ν[i] x ν[i]</code>.  The difference <code>ν[i]-ν[i+1]</code> for <code>i = 1, 2, ..., nb</code> is the number of infinite elementary divisors of degree <code>i</code>  (with <code>ν[nb+1] = 0</code>).</p><p>The dimensions of the diagonal blocks are returned in <code>blkdims = (ni, n1, n2)</code>.   </p><p>(2) if <code>finite_infinite = true</code>, then</p><pre><code class="nohighlight hljs">               | A1-λE1   *      *    |
    At - λEt = |    O   A2-λE2   *    |
               |    0     0    Ai-λEi |</code></pre><p>where the <code>ni x ni</code> subpencil <code>Ai-λEi</code> contains the infinite elementary divisors,  the <code>n1 x n1</code> subpencil <code>A1-λE1</code> is with the pair <code>(A1,E1)</code> in a generalized Schur form, and the  <code>n2 x n2</code> subpencil <code>A2-λE2</code> is with the pair <code>(A2,E2)</code> in a generalized Schur form.  The pencil <code>A1-λE1</code> has unstable finite eigenvalues and <code>A2-λE2</code> has stable finite eigenvalues if <code>stable_unstable = false</code>, while <code>A1-λE1</code> has stable finite eigenvalues and <code>A2-λE2</code> has unstable finite eigenvalues if <code>stable_unstable = true</code>.</p><p>The subpencil <code>Ai-λEi</code> is in a staircase form, with <code>Ai</code> nonsingular and upper triangular  and <code>Ei</code> nilpotent and upper triangular.  The <code>nb</code>-dimensional vectors <code>ν</code> contains the dimensions of the diagonal blocks of the staircase form <code>Ai-λEi</code> such that <code>i</code>-th block has dimensions <code>ν[i] x ν[i]</code>.  The difference <code>ν[nb-j+1]-ν[nb-j]</code> for <code>j = 1, 2, ..., nb</code> is the number of infinite elementary  divisors of degree <code>j</code> (with <code>ν[0] = 0</code>).</p><p>The dimensions of the diagonal blocks are returned in <code>blkdims = (n1, n2, ni)</code>.   </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively, the absolute tolerance for the  nonzero elements of <code>A</code>, the absolute tolerance for the nonzero elements of <code>E</code>,  and the relative tolerance  for the nonzero elements of <code>A</code> and <code>E</code>. </p><p>The reduction is performed using rank decisions based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.</p><p>The performed left orthogonal or unitary transformations are accumulated in the matrix <code>Q</code> if <code>withQ = true</code>.  Otherwise, <code>Q</code> is set to <code>nothing</code>.    The performed right orthogonal or unitary transformations are accumulated in the matrix <code>Z</code> if <code>withZ = true</code>.  Otherwise, <code>Z</code> is set to <code>nothing</code>.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixPencils.jl/blob/315e583cb9aa132ee009c727c1e0948d67c74156/src/gsep.jl#L175-L240">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixPencils.sfischursep" href="#MatrixPencils.sfischursep"><code>MatrixPencils.sfischursep</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sfischursep(A, E; smarg, disc = false, fast = true, finite_infinite = false, stable_unstable = false, atol1 = 0, atol2 = 0, rtol, withQ = true, withZ = true) -&gt; (At, Et, Q, Z, ν, blkdims)</code></pre><p>Reduce the regular matrix pencil <code>A - λE</code> to an equivalent block upper triangular form <code>At - λEt = Q&#39;*(A - λE)*Z</code>  using orthogonal or unitary transformation matrices <code>Q</code> and <code>Z</code> such that the transformed matrices <code>At</code> and <code>Et</code>  have separated infinite, stable and unstable eigenvalues with respect to a stability domain <code>Cs</code> defined by the stability margin parameter <code>smarg</code> and  the stability type parameter <code>disc</code>. If <code>disc = false</code>, <code>Cs</code> is the set of complex numbers with real parts less than <code>smarg</code>,  while if <code>disc = true</code>, <code>Cs</code> is the set of complex numbers with moduli less than <code>smarg</code> (i.e., the interior of a disc  of radius <code>smarg</code> centered in the origin). If <code>smarg = missing</code>, the default value used is <code>smarg = 0</code>, if  <code>disc = false</code>, and <code>smarg = 1</code>, if <code>disc = true</code>.</p><p>The pencil <code>At - λEt</code> results in one of the following block upper-triangular forms:</p><p>(1) if <code>finite_infinite = true</code>, then</p><pre><code class="nohighlight hljs">               | Ai1   *      *       *     |
    At - λEt = |  0  A1-λE1   *       *     |
               |  0    0    A2-λE2    *     |
               |  0    0      0    Ai2-λEi2 |</code></pre><p>where the <code>ni1 x ni1</code> matrix <code>Ai1</code> and the  <code>ni2 x ni2</code> subpencil <code>Ai2-λEi2</code> contain the infinite elementary divisors,  the <code>n1 x n1</code> subpencil <code>A1-λE1</code> is with the pair <code>(A1,E1)</code> in a generalized Schur form, and the  <code>n2 x n2</code> subpencil <code>A2-λE2</code> is with the pair <code>(A2,E2)</code> in a generalized Schur form.  The pencil <code>A1-λE1</code> has unstable finite eigenvalues and <code>A2-λE2</code> has stable finite eigenvalues if <code>stable_unstable = false</code>, while <code>A1-λE1</code> has stable finite eigenvalues and <code>A2-λE2</code> has unstable finite eigenvalues if <code>stable_unstable = true</code>.</p><p>The subpencil <code>Ai2-λEi2</code> is in a staircase form, with <code>Ai2</code> nonsingular and upper triangular and <code>Ei2</code> nilpotent and upper triangular.  The <code>nb</code>-dimensional vector <code>ν</code> contains the dimensions of the diagonal blocks of the staircase form  <code>Ai2-λEi2</code> such that <code>i</code>-th block has dimensions <code>ν[i] x ν[i]</code>.  The difference <code>ν[nb-j+2]-ν[nb-j+1]</code> for <code>j = 1, 2, ..., nb+1</code> is the number of infinite elementary  divisors of degree <code>j</code> (with <code>ν[0] := 0</code> and <code>ν[nb+1] := ni1</code>).</p><p>The dimensions of the diagonal blocks are returned in <code>blkdims = (ni1, n1, n2, ni2)</code>.   </p><p>(2) if <code>finite_infinite = false</code>, then</p><pre><code class="nohighlight hljs">               | Ai1-λEi1   *      *     *  |
               |    0     A1-λE1   *     *  |
    At - λEt = |    0       0    A2-λE2  *  |
               |    0       0      0    Ai2 |</code></pre><p>where the <code>ni1 x ni1</code> subpencil <code>Ai1-λEi1</code> and the <code>ni2 x ni2</code> upper triangular and nonsingular matrix <code>Ai2</code> contain the infinite elementary divisors of <code>A-λE</code>,  the <code>n1 x n1</code> subpencil <code>A1-λE1</code> is with the pair <code>(A1,E1)</code> in a generalized Schur form, and the  <code>n2 x n2</code> subpencil <code>A2-λE2</code> is with the pair <code>(A2,E2)</code> in a generalized Schur form.  The pencil <code>A1-λE1</code> has unstable finite eigenvalues and <code>A2-λE2</code> has stable finite eigenvalues if <code>stable_unstable = false</code>, while <code>A1-λE1</code> has stable finite eigenvalues and <code>A2-λE2</code> has unstable finite eigenvalues if <code>stable_unstable = true</code>.</p><p>The subpencil <code>Ai1-λEi1</code> is in a staircase form, with <code>Ai1</code> nonsingular and upper triangular  and <code>Ei1</code> nilpotent and upper triangular.  The <code>nb</code>-dimensional vectors <code>ν</code> contains the dimensions of the diagonal blocks of the staircase form <code>Ai1-λEi1</code> such that <code>i</code>-th block has dimensions <code>ν[i] x ν[i]</code>.  The difference <code>ν[i]-ν[i+1]</code> for <code>i = 0, 1, 2, ..., nb</code> is the number of infinite elementary divisors of degree <code>i</code>  (with <code>ν[nb+1] = 0</code> and <code>ν[0] = ni2</code>).</p><p>The dimensions of the diagonal blocks are returned in <code>blkdims = (ni1, n1, n2, ni2)</code>.   </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively, the absolute tolerance for the  nonzero elements of <code>A</code>, the absolute tolerance for the nonzero elements of <code>E</code>,  and the relative tolerance  for the nonzero elements of <code>A</code> and <code>E</code>. </p><p>The reduction is performed using rank decisions based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.</p><p>The performed left orthogonal or unitary transformations are accumulated in the matrix <code>Q</code> if <code>withQ = true</code>.  Otherwise, <code>Q</code> is set to <code>nothing</code>.    The performed right orthogonal or unitary transformations are accumulated in the matrix <code>Z</code> if <code>withZ = true</code>.  Otherwise, <code>Z</code> is set to <code>nothing</code>.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixPencils.jl/blob/315e583cb9aa132ee009c727c1e0948d67c74156/src/gsep.jl#L293-L361">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixPencils.fiblkdiag" href="#MatrixPencils.fiblkdiag"><code>MatrixPencils.fiblkdiag</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fiblkdiag(A, E, B, C; fast = true, finite_infinite = false, trinv = false, atol1 = 0, atol2 = 0, rtol, withQ = true, withZ = true) -&gt; (At, Et, Bt, Ct, Q, Z, ν, blkdims, sep)</code></pre><p>Reduce the regular matrix pencil <code>A - λE</code> to an equivalent form <code>At - λEt = Q*(A - λE)*Z</code> using  the transformation matrices <code>Q</code> and <code>Z</code> such that the transformed matrices <code>At</code> and <code>Et</code> are in one of the following block diagonal forms:</p><p>(1) if <code>finite_infinite = false</code>, then</p><pre><code class="nohighlight hljs">               | Ai-λEi |   0     |
    At - λEt = |--------|---------|, 
               |    O   | Af-λEf  |</code></pre><p>where the <code>ni x ni</code> subpencil <code>Ai-λEi</code> contains the infinite elementary  divisors and the <code>nf x nf</code> subpencil <code>Af-λEf</code>, with <code>Ef</code> nonsingular and upper triangular, contains the finite eigenvalues of the pencil <code>A-λE</code>.</p><p>The subpencil <code>Ai-λEi</code> is in a staircase form, with <code>Ai</code> nonsingular and upper triangular and <code>Ei</code> nilpotent and upper triangular.  The <code>nb</code>-dimensional vector <code>ν</code> contains the dimensions of the diagonal blocks of the staircase form  <code>Ai-λEi</code> such that <code>i</code>-th block has dimensions <code>ν[i] x ν[i]</code>.  The difference <code>ν[i]-ν[i+1]</code> for <code>i = 1, 2, ..., nb</code> is the number of infinite elementary divisors of degree <code>i</code>  (with <code>ν[nb+1] = 0</code>).</p><p>The dimensions of the diagonal blocks are returned in <code>blkdims = (ni, nf)</code>.   </p><p>(2) if <code>finite_infinite = true</code>, then</p><pre><code class="nohighlight hljs">               | Af-λEf |   0    |
    At - λEt = |--------|--------|, 
               |   O    | Ai-λEi |</code></pre><p>where the <code>nf x nf</code> subpencil <code>Af-λEf</code>, with <code>Ef</code> nonsingular and upper triangular,  contains the finite eigenvalues of the pencil <code>A-λE</code> and the <code>ni x ni</code> subpencil <code>Ai-λEi</code>  contains the infinite elementary divisors.</p><p>The subpencil <code>Ai-λEi</code> is in a staircase form, with <code>Ai</code> nonsingular and upper triangular  and <code>Ei</code> nilpotent and upper triangular.  The <code>nb</code>-dimensional vectors <code>ν</code> contains the dimensions of the diagonal blocks of the staircase form <code>Ai-λEi</code> such that <code>i</code>-th block has dimensions <code>ν[i] x ν[i]</code>.  The difference <code>ν[nb-j+1]-ν[nb-j]</code> for <code>j = 1, 2, ..., nb</code> is the number of infinite elementary  divisors of degree <code>j</code> (with <code>ν[0] = 0</code>).</p><p>The dimensions of the diagonal blocks are returned in <code>blkdims = (nf, ni)</code>.   </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively, the absolute tolerance for the  nonzero elements of <code>A</code>, the absolute tolerance for the nonzero elements of <code>E</code>,  and the relative tolerance  for the nonzero elements of <code>A</code> and <code>E</code>. </p><p>The reduction is performed using rank decisions based on rank revealing QR-decomdiagpositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.</p><p>If <code>withQ = true</code>, <code>Q</code> contains the left transformation matrix, if <code>trinv = false</code>, or its inverse, if <code>trinv = true</code>.  If <code>withQ = false</code>, <code>Q</code> is set to <code>nothing</code>.    If <code>withZ = true</code>, <code>Z</code> contains the right transformation matrix, if <code>trinv = false</code>, or its inverse, if <code>trinv = true</code>.  If <code>withZ = false</code>, <code>Z</code> is set to <code>nothing</code>.   </p><p><code>Bt = Q*B</code>, unless <code>B = missing</code>, in which case <code>Bt = missing</code> is returned, and <code>Ct = C*Z</code>,  unless <code>C = missing</code>, in which case <code>Ct = missing</code> is returned .              </p><p>An estimation of the separation of the spectra of <code>Ai-λEi</code> and <code>Af-λEf</code> is returned in <code>sep</code>, where  <code>0 &lt; sep ≤ 1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixPencils.jl/blob/315e583cb9aa132ee009c727c1e0948d67c74156/src/gsep.jl#L410-L468">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixPencils.gsblkdiag" href="#MatrixPencils.gsblkdiag"><code>MatrixPencils.gsblkdiag</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gsblkdiag(A, E, B, C; smarg, disc = false, fast = true, finite_infinite = false, stable_unstable = false, trinv = false, 
          atol1 = 0, atol2 = 0, rtol, withQ = true, withZ = true) -&gt; (At, Et, Bt, Ct, Q, Z, ν, blkdims, sep)</code></pre><p>Reduce the regular matrix pencil <code>A - λE</code> to an equivalent block diagonal triangular form <code>At - λEt = Q*(A - λE)*Z</code>  using the transformation matrices <code>Q</code> and <code>Z</code> such that the transformed matrices <code>At</code> and <code>Et</code>  have separated infinite, stable and unstable eigenvalues with respect to a stability domain <code>Cs</code>  defined by the stability margin parameter <code>smarg</code> and the stability type parameter <code>disc</code>.  If <code>disc = false</code>, <code>Cs</code> is the set of complex numbers with real parts less than <code>smarg</code>,  while if <code>disc = true</code>, <code>Cs</code> is the set of complex numbers with moduli less than <code>smarg</code> (i.e., the interior of a disc  of radius <code>smarg</code> centered in the origin). If <code>smarg = missing</code>, the default value used is <code>smarg = 0</code>, if  <code>disc = false</code>, and <code>smarg = 1</code>, if <code>disc = true</code>.</p><p>The pencil <code>At - λEt</code> results in one of the following block upper-triangular forms:</p><p>(1) if <code>finite_infinite = false</code>, then</p><pre><code class="nohighlight hljs">               | Ai-λEi   *      0    |
    At - λEt = |    O   A1-λE1   0    |
               |    0     0    A2-λE2 |</code></pre><p>where the <code>ni x ni</code> subpencil <code>Ai-λEi</code> contains the infinite elementary divisors,  the <code>n1 x n1</code> subpencil <code>A1-λE1</code> is with the pair <code>(A1,E1)</code> in a generalized Schur form, and the  <code>n2 x n2</code> subpencil <code>A2-λE2</code> is with the pair <code>(A2,E2)</code> in a generalized Schur form.  The pencil <code>A1-λE1</code> has unstable finite eigenvalues and <code>A2-λE2</code> has stable finite eigenvalues if <code>stable_unstable = false</code>, while <code>A1-λE1</code> has stable finite eigenvalues and <code>A2-λE2</code> has unstable finite eigenvalues if <code>stable_unstable = true</code>.</p><p>The subpencil <code>Ai-λEi</code> is in a staircase form, with <code>Ai</code> nonsingular and upper triangular and <code>Ei</code> nilpotent and upper triangular.  The <code>nb</code>-dimensional vector <code>ν</code> contains the dimensions of the diagonal blocks of the staircase form  <code>Ai-λEi</code> such that <code>i</code>-th block has dimensions <code>ν[i] x ν[i]</code>.  The difference <code>ν[i]-ν[i+1]</code> for <code>i = 1, 2, ..., nb</code> is the number of infinite elementary divisors of degree <code>i</code>  (with <code>ν[nb+1] = 0</code>).</p><p>The dimensions of the diagonal blocks are returned in <code>blkdims = (ni, n1, n2)</code>.   </p><p>(2) if <code>finite_infinite = true</code>, then</p><pre><code class="nohighlight hljs">               | A1-λE1   0      0    |
    At - λEt = |    O   A2-λE2   *    |
               |    0     0    Ai-λEi |</code></pre><p>where the <code>ni x ni</code> subpencil <code>Ai-λEi</code> contains the infinite elementary divisors,  the <code>n1 x n1</code> subpencil <code>A1-λE1</code> is with the pair <code>(A1,E1)</code> in a generalized Schur form, and the  <code>n2 x n2</code> subpencil <code>A2-λE2</code> is with the pair <code>(A2,E2)</code> in a generalized Schur form.  The pencil <code>A1-λE1</code> has unstable finite eigenvalues and <code>A2-λE2</code> has stable finite eigenvalues if <code>stable_unstable = false</code>, while <code>A1-λE1</code> has stable finite eigenvalues and <code>A2-λE2</code> has unstable finite eigenvalues if <code>stable_unstable = true</code>.</p><p>The subpencil <code>Ai-λEi</code> is in a staircase form, with <code>Ai</code> nonsingular and upper triangular  and <code>Ei</code> nilpotent and upper triangular.  The <code>nb</code>-dimensional vectors <code>ν</code> contains the dimensions of the diagonal blocks of the staircase form <code>Ai-λEi</code> such that <code>i</code>-th block has dimensions <code>ν[i] x ν[i]</code>.  The difference <code>ν[nb-j+1]-ν[nb-j]</code> for <code>j = 1, 2, ..., nb</code> is the number of infinite elementary  divisors of degree <code>j</code> (with <code>ν[0] = 0</code>).</p><p>The dimensions of the diagonal blocks are returned in <code>blkdims = (n1, n2, ni)</code>.   </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively, the absolute tolerance for the  nonzero elements of <code>A</code>, the absolute tolerance for the nonzero elements of <code>E</code>,  and the relative tolerance  for the nonzero elements of <code>A</code> and <code>E</code>. </p><p>The reduction is performed using rank decisions based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.</p><p>If <code>withQ = true</code>, <code>Q</code> contains the left transformation matrix, if <code>trinv = false</code>, or its inverse, if <code>trinv = true</code>.  If <code>withQ = false</code>, <code>Q</code> is set to <code>nothing</code>.    If <code>withZ = true</code>, <code>Z</code> contains the left transformation matrix, if <code>trinv = false</code>, or its inverse, if <code>trinv = true</code>.  If <code>withZ = false</code>, <code>Z</code> is set to <code>nothing</code>.   </p><p><code>Bt = Q*B</code>, unless <code>B = missing</code>, in which case <code>Bt = missing</code> is returned, and <code>Ct = C*Z</code>,  unless <code>C = missing</code>, in which case <code>Ct = missing</code> is returned .              </p><p>An estimation of the separation of the spectra of the two underlying diagonal blocks is returned in <code>sep</code>,  where  <code>0 ≤ sep ≤ 1</code>. A value <code>sep ≈ 0</code> indicates that <code>A1-λE1</code> and <code>A2-λE2</code> have some almost equal eigenvalues. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixPencils.jl/blob/315e583cb9aa132ee009c727c1e0948d67c74156/src/gsep.jl#L519-L592">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixPencils.ssblkdiag" href="#MatrixPencils.ssblkdiag"><code>MatrixPencils.ssblkdiag</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ssblkdiag(A, B, C; smarg, disc = false, stable_unstable = false, withQ = true, withZ = true) -&gt; (At, Bt, Ct, Q, Z, blkdims, sep)</code></pre><p>Reduce the regular matrix pencil <code>A - λI</code> to an equivalent block diagonal triangular form <code>At - λI = Q*(A - λI)*Z</code>  using the transformation matrices <code>Q</code> and <code>Z</code>, where <code>Q = inv(Z)</code>, such that the transformed matrix <code>At</code> have  separated stable and unstable eigenvalues with respect to a stability domain <code>Cs</code> defined by the  stability margin parameter <code>smarg</code> and the stability type parameter <code>disc</code>.  If <code>disc = false</code>, <code>Cs</code> is the set of complex numbers with real parts less than <code>smarg</code>,  while if <code>disc = true</code>, <code>Cs</code> is the set of complex numbers with moduli less than <code>smarg</code> (i.e., the interior of a disc  of radius <code>smarg</code> centered in the origin). If <code>smarg = missing</code>, the default value used is <code>smarg = 0</code>, if  <code>disc = false</code>, and <code>smarg = 1</code>, if <code>disc = true</code>. The matrix <code>At</code> results in the following block diagonal form</p><pre><code class="nohighlight hljs">    At = | A1  0  |
         | 0   A2 |</code></pre><p>where the <code>n1 x n1</code> matrix <code>A1</code> and the <code>n2 x n2</code> matrix <code>A2</code> are in Schur form.  The matrix <code>A1</code> has unstable eigenvalues and <code>A2</code> has stable eigenvalues if <code>stable_unstable = false</code>, while <code>A1</code> has stable eigenvalues and <code>A2</code> has unstable eigenvalues if <code>stable_unstable = true</code>. The dimensions of the diagonal blocks are returned in <code>blkdims = (n1, n2)</code>.    If <code>withQ = true</code>, <code>Q</code> contains the left transformation matrix. If <code>withQ = false</code>, <code>Q</code> is set to <code>nothing</code>.    If <code>withZ = true</code>, <code>Z</code> contains the right transformation matrix. If <code>withZ = false</code>, <code>Z</code> is set to <code>nothing</code>.    <code>Bt = Q*B</code>, unless <code>B = missing</code>, in which case <code>Bt = missing</code> is returned, and <code>Ct = C*Z</code>,  unless <code>C = missing</code>, in which case <code>Ct = missing</code> is returned .               An estimation of the separation of the spectra of the two underlying diagonal blocks is returned in <code>sep</code>,  where  <code>0 ≤ sep ≤ 1</code>. A value <code>sep ≈ 0</code> indicates that <code>A1</code> and <code>A2</code> have some almost equal eigenvalues. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixPencils.jl/blob/315e583cb9aa132ee009c727c1e0948d67c74156/src/gsep.jl#L657-L683">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixPencils.saloc" href="#MatrixPencils.saloc"><code>MatrixPencils.saloc</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">saloc(A, B; evals, sdeg, disc = false, atol1 = 0, atol2 = 0, rtol) -&gt; (F, Scl, blkdims)</code></pre><p>Compute for the pair <code>(A,B)</code>, a matrix <code>F</code> such that all eigenvalues of the matrix <code>A+B*F</code> lie in the stability domain <code>Cs</code>  specified by the stability degree parameter <code>sdeg</code> and stability type parameter <code>disc</code>.  If <code>disc = false</code>, <code>Cs</code> is the set of complex numbers with real parts at most <code>sdeg</code>, while if <code>disc = true</code>,  <code>Cs</code> is the set of complex numbers with moduli at most <code>sdeg</code> (i.e., the interior of a disc of radius <code>sdeg</code> centered in the origin).  <code>evals</code> is a real or complex vector, which contains the desired eigenvalues of the matrix <code>A+B*F</code> within <code>Cs</code>.  For real data <code>A</code> and <code>B</code>, <code>evals</code> must be a self-conjugated complex set to ensure that the resulting <code>F</code> is also a real matrix. </p><p>For a pair <code>(A,B)</code> with <code>A</code> of order <code>n</code>, the number of assignable eigenvalues is <code>nc := n-nu</code>,   where <code>nu</code> is the number of fixed eigenvalues of <code>A</code>. The assignable eigenvalues are called the controllable eigenvalues,  while the fixed eigenvalues are called the <em>uncontrollable eigenvalues</em> (these are the zeros of the pencil <code>[A-λI B]</code>).  The spectrum allocation is achieved by successively replacing the <em>controllable eigenvalues</em> of <code>A</code> lying outside of the  stability domain <code>Cs</code> with eigenvalues provided in <code>evals</code>. All eigenvalues of <code>A</code> lying in <code>Cs</code> are kept unalterred.   If the number of specified eigenvalues in <code>evals</code> is less than the number of controllable eigenvalues of <code>A</code> outside of <code>Cs</code> (e.g., if <code>evals = missing</code>), then some of the controllable eigenvalues of <code>A</code> are assigned to the nearest values  on the boundary of <code>Cs</code>. If <code>sdeg = missing</code> and <code>evals = missing</code>, the default value used for <code>sdeg</code> is -0.05  if  <code>disc = false</code> and 0.95 if <code>disc = true</code>. </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively, the absolute tolerance for the  nonzero elements of <code>A</code>, the absolute tolerance for the nonzero elements of <code>B</code>,   and the relative tolerance for the nonzero elements of <code>A</code> and <code>B</code>.   The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the machine epsilon of the element type of <code>A</code>. </p><p>The resulting matrix <code>Acl := Z&#39;*(A+B*F)*Z</code> in a Schur form, where <code>Z</code> is the orthogonal/unitary matrix used  to obtain the matrix <code>A+B*F</code> in Schur form, has the form</p><pre><code class="nohighlight hljs">       ( Ag  *   *  )     
 Acl = ( 0   Aa  *  ) 
       ( 0   0   Au )</code></pre><p>where:  <code>Ag</code> contains the <code>ng</code> eigenvalues of <code>A</code> in <code>Cs</code>, <code>Aa</code> contains the <code>na</code> assigned eigenvalues in <code>Cs</code> and <code>Au</code> contains <code>nu</code> uncontrollable eigenvalues of <code>A</code> lying outside <code>Cs</code>.  The matrices <code>Acl</code> and <code>Z</code> and the vector <code>α</code> of eigenvalues of <code>Acl</code> (also of <code>A+B*F</code>) are returned in the <code>Schur</code> object <code>Scl</code>.  The values of <code>ng</code>, <code>na</code> and <code>nu</code> are returned in the 3-dimensional vector <code>blkdims = [ng, na, nu]</code>.</p><p>Method:  The Schur method of [1], extended to possibly uncontrollable pairs, is employed.  </p><p>References:</p><p>[1] A. Varga.      A Schur method for pole assignment.     IEEE Trans. on Automatic Control, vol. 26, pp. 517-519, 1981.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixPencils.jl/blob/315e583cb9aa132ee009c727c1e0948d67c74156/src/gsfstab.jl#L134-L179">source</a></section><section><div><pre><code class="language-julia hljs">saloc(A, E, B; evals, sdeg, disc = false, atol1 = 0, atol2 = 0, atol3 = 0, rtol, sepinf = true, fast = true) -&gt; (F, Scl, blkdims)</code></pre><p>Compute for the pair <code>(A-λE,B)</code>, with <code>A-λE</code> a regular pencil, a matrix <code>F</code> such that all finite eigenvalues of the  pencil <code>A+B*F-λE</code> lie in the stability domain <code>Cs</code> specified by the stability degree parameter <code>sdeg</code> and stability type parameter <code>disc</code>.  If <code>disc = false</code>, <code>Cs</code> is the set of complex numbers with real parts at most <code>sdeg</code>, while if <code>disc = true</code>,  <code>Cs</code> is the set of complex numbers with moduli at most <code>sdeg</code> (i.e., the interior of a disc of radius <code>sdeg</code> centered in the origin).  <code>evals</code> is a real or complex vector, which contains a set of finite desired eigenvalues for the pencil <code>A+B*F-λE</code>.  For real data <code>A</code>, <code>E</code>, and <code>B</code>, <code>evals</code> must be a self-conjugated complex set to ensure that the resulting <code>F</code> is also a real matrix. </p><p>For a pair <code>(A-λE,B)</code> with <code>A</code> of order <code>n</code>, the number of assignable finite eigenvalues is <code>nfc := n-ninf-nfu</code>,   where <code>ninf</code> is the number of infinite eigenvalues of <code>A-λE</code> and <code>nfu</code> is the number of fixed finite eigenvalues of <code>A-λE</code>.  The assignable finite eigenvalues are called the <em>controllable finite eigenvalues</em>,  while the fixed finite eigenvalues are called the <em>uncontrollable finite eigenvalues</em> (these are the finite zeros of the pencil <code>[A-λE B]</code>).  The spectrum allocation is achieved by successively replacing the controllable finite eigenvalues of <code>A-λE</code> lying outside of the  stability domain <code>Cs</code> with eigenvalues provided in <code>evals</code>. All finite eigenvalues of <code>A-λE</code> lying in <code>Cs</code> are kept unalterred.   If the number of specified eigenvalues in <code>evals</code> is less than the number of controllable finite eigenvalues of <code>A-λE</code> outside of <code>Cs</code> (e.g., if <code>evals = missing</code>), then some of the controllable finite eigenvalues of <code>A-λE</code> are assigned to the nearest values  on the boundary of <code>Cs</code>. If <code>sdeg = missing</code> and <code>evals = missing</code>, the default value used for <code>sdeg</code> is -0.05  if  <code>disc = false</code> and 0.95 if <code>disc = true</code>. </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, <code>atol3</code>, and <code>rtol</code>, specify, respectively, the absolute tolerance for the  nonzero elements of <code>A</code>, the absolute tolerance for the nonzero elements of <code>E</code>, the absolute tolerance for the nonzero elements of <code>B</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>E</code> and <code>B</code>.   The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the machine epsilon of the element type of <code>A</code>. </p><p>The keyword argument <code>sepinf</code> specifies the option for a preliminary separation  of the infinite eigenvalues of the pencil <code>A-λE</code> as follows: if <code>sepinf = false</code>, no separation of infinite eigenvalues is performed,  while for <code>sepinf = true</code> (the default option), a preliminary separation of the infinite eigenvalues from the finite ones is performed. If <code>E</code> is nonsingular, then <code>sepinf = false</code> is recommended to be used. If <code>E</code> is numerically singular, then the option <code>sepinf = false</code> is used.  The separation of finite and infinite eigenvalues is performed using rank decisions based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.</p><p>The resulting pencil <code>Acl-λEcl := Q&#39;*(A+B*F-λE)*Z</code>,  where <code>Q</code> and <code>Z</code> are the   orthogonal/unitary matrices used to obtain the pair <code>(Acl,Ecl)</code> in a generalized Schur form (GSF), has the form</p><pre><code class="nohighlight hljs">            ( Ai-λEi    *        *       *      )     
 Acl-λEcl = (   0    Afg-λEfg    *       *      )  
            (   0       0     Afa-λEfa   *      )    
            (   0       0        0     Afu-λEfu )</code></pre><p>where: <code>Ai-λEi</code> with <code>Ai</code> upper triangular and invertible and <code>Ei</code> upper triangular and nilpotent, contains the <code>ninf</code> infinite eigenvalues of <code>A-λE</code>;  <code>Afg-λEfg</code> contains <code>nfg</code> finite eigenvalues of <code>A-λE</code> in <code>Cs</code>; <code>Afa-λEfa</code> contains <code>nfa</code> assigned finite generalized eigenvalues in <code>Cs</code>;  and <code>Afu-λEfu</code> contains <code>nfu</code> uncontrollable finite eigenvalues of <code>A-λE</code> lying outside <code>Cs</code>.  The matrices <code>Acl</code>, <code>Ecl</code>, <code>Q</code>, <code>Z</code> and the vectors <code>α</code> and <code>β</code> such that <code>α./β</code> are the generalized eigenvalues of  the pair <code>(Acl,Ecl)</code> are returned in the <code>GeneralizeSchur</code> object <code>Scl</code>.  The values of <code>ninf</code>, <code>nfg</code>, <code>nfa</code> and <code>nfu</code> are returned in the 4-dimensional vector <code>blkdims = [ninf, nfg, nfa, nfu]</code>.</p><p>Method:  For a pair <code>(A-λE,B)</code> with <code>E = I</code>, the Schur method of [1] is used, while for a general pair <code>(A-λE,B)</code> the generalized Schur method of [2]  is used to solve the R-stabilzation problem.</p><p>References:</p><p>[1] A. Varga.      A Schur method for pole assignment.     IEEE Trans. on Automatic Control, vol. 26, pp. 517-519, 1981.</p><p>[2] A. Varga.      On stabilization methods of descriptor systems.     Systems &amp; Control Letters, vol. 24, pp.133-138, 1995.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixPencils.jl/blob/315e583cb9aa132ee009c727c1e0948d67c74156/src/gsfstab.jl#L415-L476">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixPencils.salocd" href="#MatrixPencils.salocd"><code>MatrixPencils.salocd</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">salocd(A, C; evals, sdeg, disc = false, atol1 = 0, atol2 = 0, rtol) -&gt; (K, Scl, blkdims)</code></pre><p>Compute for the pair <code>(A,C)</code>, a matrix <code>K</code> such that all eigenvalues of the matrix <code>A+K*C</code> lie in the stability domain <code>Cs</code>  specified by the stability degree parameter <code>sdeg</code> and stability type parameter <code>disc</code>.  If <code>disc = false</code>, <code>Cs</code> is the set of complex numbers with real parts at most <code>sdeg</code>, while if <code>disc = true</code>,  <code>Cs</code> is the set of complex numbers with moduli at most <code>sdeg</code> (i.e., the interior of a disc of radius <code>sdeg</code> centered in the origin).  <code>evals</code> is a real or complex vector, which contains the desired eigenvalues of the matrix <code>A+K*C</code> within <code>Cs</code>.  For real data <code>A</code> and <code>C</code>, <code>evals</code> must be a self-conjugated complex set to ensure that the resulting <code>K</code> is also a real matrix. </p><p>For a pair <code>(A,C)</code> with <code>A</code> of order <code>n</code>, the number of assignable eigenvalues is <code>nc := n-nu</code>,   where <code>nu</code> is the number of fixed eigenvalues of <code>A</code>. The assignable eigenvalues are called the <em>observable eigenvalues</em>,  while the fixed eigenvalues are called the <em>unobservable eigenvalues</em> (these are the zeros of the pencil <code>[A-λI; C]</code>).  The spectrum allocation is achieved by successively replacing the observable eigenvalues of <code>A</code> lying outside of the  stability domain <code>Cs</code> with eigenvalues provided in <code>evals</code>. All eigenvalues of <code>A</code> lying in <code>Cs</code> are kept unalterred.   If the number of specified eigenvalues in <code>evals</code> is less than the number of observable eigenvalues of <code>A</code> outside of <code>Cs</code> (e.g., if <code>evals = missing</code>), then some of the observable eigenvalues of <code>A</code> are assigned to the nearest values  on the boundary of <code>Cs</code>. If <code>sdeg = missing</code> and <code>evals = missing</code>, the default value used for <code>sdeg</code> is -0.05  if  <code>disc = false</code> and 0.95 if <code>disc = true</code>. </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively, the absolute tolerance for the  nonzero elements of <code>A</code>, the absolute tolerance for the nonzero elements of <code>C</code>,   and the relative tolerance for the nonzero elements of <code>A</code> and <code>C</code>.   The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the machine epsilon of the element type of <code>A</code>. </p><p>The resulting matrix <code>Acl := Z&#39;*(A+K*C)*Z</code> in a Schur form, where <code>Z</code> is the orthogonal/unitary matrix used  to obtain the matrix <code>A+K*C</code> in Schur form, has the form</p><pre><code class="nohighlight hljs">       ( Au  *   *  )     
 Acl = ( 0   Aa  *  ) 
       ( 0   0   Ag )</code></pre><p>where:  <code>Au</code> contains <code>nu</code> unobservable eigenvalues of <code>A</code> lying outside <code>Cs</code>,  <code>Aa</code> contains the <code>na</code> assigned eigenvalues in <code>Cs</code> and <code>Ag</code> contains the <code>ng</code> eigenvalues of <code>A</code> in <code>Cs</code>.  The matrices <code>Acl</code> and <code>Z</code> and the vector <code>α</code> of eigenvalues of <code>Acl</code> (also of <code>A+K*C</code>) are returned in the <code>Schur</code> object <code>Scl</code>.  The values of <code>nu</code>, <code>na</code> and <code>ng</code> are returned in the 3-dimensional vector <code>blkdims = [nu, na, ng]</code>.</p><p>Method:  The Schur method of [1] is applied to the dual pair <code>(A&#39;,C&#39;)</code> (extended to possibly unobservable pairs).  </p><p>References:</p><p>[1] A. Varga.      A Schur method for pole assignment.     IEEE Trans. on Automatic Control, vol. 26, pp. 517-519, 1981.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixPencils.jl/blob/315e583cb9aa132ee009c727c1e0948d67c74156/src/gsfstab.jl#L1-L46">source</a></section><section><div><pre><code class="language-julia hljs">salocd(A, E, C; evals, sdeg, disc = false, atol1 = 0, atol2 = 0, atol3 = 0, rtol, sepinf = true, fast = true) -&gt; (K, Scl, blkdims)</code></pre><p>Compute for the pair <code>(A-λE,C)</code>, with <code>A-λE</code> a regular pencil, a matrix <code>K</code> such that all finite eigenvalues of the  pencil <code>A+K*C-λE</code> lie in the stability domain <code>Cs</code> specified by the stability degree parameter <code>sdeg</code> and stability type parameter <code>disc</code>.  If <code>disc = false</code>, <code>Cs</code> is the set of complex numbers with real parts at most <code>sdeg</code>, while if <code>disc = true</code>,  <code>Cs</code> is the set of complex numbers with moduli at most <code>sdeg</code> (i.e., the interior of a disc of radius <code>sdeg</code> centered in the origin).  <code>evals</code> is a real or complex vector, which contains a set of finite desired eigenvalues for the pencil <code>A+K*C-λE</code>.  For real data <code>A</code>, <code>E</code>, and <code>B</code>, <code>evals</code> must be a self-conjugated complex set to ensure that the resulting <code>F</code> is also a real matrix. </p><p>For a pair <code>(A-λE,C)</code> with <code>A</code> of order <code>n</code>, the number of assignable finite eigenvalues is <code>nfc := n-ninf-nfu</code>,   where <code>ninf</code> is the number of infinite eigenvalues of <code>A-λE</code> and <code>nfu</code> is the number of fixed finite eigenvalues of <code>A-λE</code>.  The assignable finite eigenvalues are called the <em>observable finite eigenvalues</em>,  while the fixed finite eigenvalues are called the <em>unobservable finite eigenvalues</em> (these are the finite zeros of the pencil <code>[A-λE; C]</code>).  The spectrum allocation is achieved by successively replacing the observable finite eigenvalues of <code>A-λE</code> lying outside of the  stability domain <code>Cs</code> with eigenvalues provided in <code>evals</code>. All finite eigenvalues of <code>A-λE</code> lying in <code>Cs</code> are kept unalterred.   If the number of specified eigenvalues in <code>evals</code> is less than the number of observable finite eigenvalues of <code>A-λE</code> outside of <code>Cs</code> (e.g., if <code>evals = missing</code>), then some of the observable finite eigenvalues of <code>A-λE</code> are assigned to the nearest values  on the boundary of <code>Cs</code>. If <code>sdeg = missing</code> and <code>evals = missing</code>, the default value used for <code>sdeg</code> is -0.05  if  <code>disc = false</code> and 0.95 if <code>disc = true</code>. </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, , <code>atol3</code>, and <code>rtol</code>, specify, respectively, the absolute tolerance for the  nonzero elements of <code>A</code>, the absolute tolerance for the nonzero elements of <code>E</code>, the absolute tolerance for the nonzero elements of <code>C</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>E</code> and <code>C</code>.   The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the machine epsilon of the element type of <code>A</code>. </p><p>The keyword argument <code>sepinf</code> specifies the option for a preliminary separation  of the infinite eigenvalues of the pencil <code>A-λE</code> as follows: if <code>sepinf = false</code>, no separation of infinite eigenvalues is performed,  while for <code>sepinf = true</code> (the default option), a preliminary separation of the infinite eigenvalues from the finite ones is performed. If <code>E</code> is nonsingular, then <code>sepinf = false</code> is recommended to be used. If <code>E</code> is numerically singular, then the option <code>sepinf = false</code> is used.  The separation of finite and infinite eigenvalues is performed using rank decisions based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.</p><p>The resulting pencil <code>Acl-λEcl := Q&#39;*(A+K*C-λE)*Z</code>,  where <code>Q</code> and <code>Z</code> are the   orthogonal/unitary matrices used to obtain the pair <code>(Acl,Ecl)</code> in a generalized Schur form (GSF), has the form</p><pre><code class="nohighlight hljs">            ( Afu-λEfu    *        *       *    )     
 Acl-λEcl = (   0      Afa-λEfa    *       *    )  
            (   0         0     Afg-λEfg   *    )    
            (   0         0        0     Ai-λEi )</code></pre><p>where: <code>Afu-λEfu</code> contains <code>nfu</code> unobservable finite eigenvalues of <code>A-λE</code> lying outside <code>Cs</code>, <code>Afa-λEfa</code> contains <code>nfa</code> assigned finite generalized eigenvalues in <code>Cs</code>,  <code>Afg-λEfg</code> contains <code>nfg</code> finite eigenvalues of <code>A-λE</code> in <code>Cs</code>, and  <code>Ai-λEi</code>, with <code>Ai</code> upper triangular and invertible and <code>Ei</code> upper triangular and nilpotent,  contains the <code>ninf</code> infinite eigenvalues of <code>A-λE</code>.   The matrices <code>Acl</code>, <code>Ecl</code>, <code>Q</code>, <code>Z</code> and the vectors <code>α</code> and <code>β</code> such that <code>α./β</code> are the generalized eigenvalues of  the pair <code>(Acl,Ecl)</code> are returned in <code>GeneralizeSchur</code> object <code>Scl</code>.  The values of <code>nfu</code>, <code>nfa</code>, <code>nfg</code> and <code>ninf</code> and are returned in the 4-dimensional vector <code>blkdims = [nfu, nfa, nfg, ninf]</code>.</p><p>Method:  For a pair <code>(A-λE,C)</code> with <code>E = I</code>, the dual Schur method of [1] is used, while for a general pair <code>(A-λE,C)</code> the dual generalized Schur method of [2]  is used to solve the R-stabilzation problem of [2] for the dual pair <code>(A&#39;-λE&#39;,C&#39;)</code>.</p><p>References:</p><p>[1] A. Varga.      A Schur method for pole assignment.     IEEE Trans. on Automatic Control, vol. 26, pp. 517-519, 1981.</p><p>[2] A. Varga.      On stabilization methods of descriptor systems.     Systems &amp; Control Letters, vol. 24, pp.133-138, 1995.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixPencils.jl/blob/315e583cb9aa132ee009c727c1e0948d67c74156/src/gsfstab.jl#L57-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixPencils.salocinf" href="#MatrixPencils.salocinf"><code>MatrixPencils.salocinf</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">salocinf(A, E, B; atol1 = 0, atol2 = 0, atol3 = 0, rtol, fast = true) -&gt; (F, G, Scl, blkdims)</code></pre><p>Compute for the controllable pair <code>(A-λE,B)</code>, with <code>A-λE</code> a regular pencil, two matrices <code>F</code> and <code>G</code> such that all eigenvalues of the  pencil <code>A+B*F-λ(E+B*G)</code> are infinite. For a pair <code>(A-λE,B)</code> with fixed (uncontrollable) finite eigenvalues, only the assignable (controllable)  finite eigenvalues are moved to infinity. </p><p>For a pair <code>(A-λE,B)</code> with <code>A</code> of order <code>n</code>, the number of assignable infinite eigenvalues is <code>nia := n-ninf-nfu</code>,   where <code>ninf</code> is the number of infinite eigenvalues of <code>A-λE</code> and <code>nfu</code> is the number of fixed finite eigenvalues of <code>A-λE</code>.  The assignable finite eigenvalues are called the <em>controllable finite eigenvalues</em>,  while the fixed finite eigenvalues are called the <em>uncontrollable finite eigenvalues</em> (these are the finite zeros of the pencil <code>[A-λE B]</code>).  The spectrum allocation is achieved by successively replacing the controllable finite eigenvalues of <code>A-λE</code> with infinite eigenvalues.  All infinite eigenvalues of <code>A-λE</code> are kept unalterred.</p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, <code>atol3</code>, and <code>rtol</code>, specify, respectively, the absolute tolerance for the  nonzero elements of <code>A</code>, the absolute tolerance for the nonzero elements of <code>E</code>, the absolute tolerance for the nonzero elements of <code>B</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>E</code> and <code>B</code>.   The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the machine epsilon of the element type of <code>A</code>. </p><p>The preliminary separation of finite and infinite eigenvalues is performed using rank decisions based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.</p><p>The resulting pencil <code>Acl-λEcl := Q&#39;*(A+B*F-λ(E+B*G))*Z</code>,  where <code>Q</code> and <code>Z</code> are the   orthogonal/unitary matrices used to obtain the pair <code>(Acl,Ecl)</code> in a generalized Schur form (GSF), has the form</p><pre><code class="nohighlight hljs">            ( Aig-λEig    *        *     )     
 Acl-λEcl = (   0      Aia-λEia    *     )  
            (   0         0     Afu-λEfu )</code></pre><p>where: <code>Aig-λEig</code> with <code>Aig</code> upper triangular and invertible and <code>Eig</code> upper triangular and nilpotent, contains the <code>ninf</code> infinite eigenvalues of <code>A-λE</code>;  <code>Aia-λEia</code>, with <code>Aia</code> upper triangular and invertible and <code>Eia</code> upper triangular and nilpotent, contains <code>nia</code> assigned infinite generalized eigenvalues;  and <code>Afu-λEfu</code>, with the pair <code>(Afu,Efu)</code> in a generalized Schur form,  contains <code>nfu</code> fixed (uncontrollable) finite eigenvalues of <code>A-λE</code>.  The matrices <code>Acl</code>, <code>Ecl</code>, <code>Q</code>, <code>Z</code> and the vectors <code>α</code> and <code>β</code> such that <code>α./β</code> are the generalized eigenvalues of  the pair <code>(Acl,Ecl)</code> are returned in the <code>GeneralizeSchur</code> object <code>Scl</code>.  The values of <code>ninf</code>, <code>nia</code> and <code>nfu</code> are returned in the 3-dimensional vector <code>blkdims = [ninf, nia, nfu]</code>.</p><p>Method:  For a general pair <code>(A-λE,B)</code> the modified generalized Schur method of [1] is used to determine <code>F</code> and <code>G</code> such that the pair <code>(A+B*F,E+B*G)</code> has only infinite eigenvalues.</p><p>References:</p><p>[1] A. Varga.      On stabilization methods of descriptor systems.     Systems &amp; Control Letters, vol. 24, pp.133-138, 1995.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixPencils.jl/blob/315e583cb9aa132ee009c727c1e0948d67c74156/src/gsfstab.jl#L822-L866">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixPencils.salocinfd" href="#MatrixPencils.salocinfd"><code>MatrixPencils.salocinfd</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">salocinfd(A, E, C; atol1 = 0, atol2 = 0, atol3 = 0, rtol, sepinf = true, fast = true) -&gt; (K, L, Scl, blkdims)</code></pre><p>Compute for the pair <code>(A-λE,C)</code>, with <code>A-λE</code> a regular pencil, the matrices <code>K</code> and <code>L</code> such that all eigenvalues of the  pencil <code>A+K*C-λ(E+L*C)</code> are infinite. For a pair <code>(A-λE,C)</code> with fixed (unobservable) finite eigenvalues, only the assignable (observable) finite eigenvalues are moved to infinity. </p><p>For a pair <code>(A-λE,C)</code> with <code>A</code> of order <code>n</code>, the number of assignable infinite eigenvalues is <code>nia := n-ninf-nfu</code>,   where <code>ninf</code> is the number of infinite eigenvalues of <code>A-λE</code> and <code>nfu</code> is the number of fixed finite eigenvalues of <code>A-λE</code>.  The assignable finite eigenvalues are called the <em>observable finite eigenvalues</em>,  while the fixed finite eigenvalues are called the <em>unobservable finite eigenvalues</em> (these are the finite zeros of the pencil <code>[A-λE; C]</code>).  The spectrum allocation is achieved by successively replacing the observable finite eigenvalues of <code>A-λE</code> with infinite eigenvalues.  All infinite eigenvalues of <code>A-λE</code> are kept unalterred.</p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, , <code>atol3</code>, and <code>rtol</code>, specify, respectively, the absolute tolerance for the  nonzero elements of <code>A</code>, the absolute tolerance for the nonzero elements of <code>E</code>, the absolute tolerance for the nonzero elements of <code>C</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>E</code> and <code>C</code>.   The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the machine epsilon of the element type of <code>A</code>. </p><p>The preliminary separation of finite and infinite eigenvalues is performed using rank decisions based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.</p><p>The resulting pencil <code>Acl-λEcl := Q&#39;*(A+K*C-λ(E+L*C))*Z</code>,  where <code>Q</code> and <code>Z</code> are the   orthogonal/unitary matrices used to obtain the pair <code>(Acl,Ecl)</code> in a generalized Schur form (GSF), has the form</p><pre><code class="nohighlight hljs">            ( Afu-λEfu    *        *     )     
 Acl-λEcl = (   0      Aia-λEia    *     )  
            (   0         0     Aig-λEig )</code></pre><p>where: <code>Afu-λEfu</code>, with the pair <code>(Afu,Efu)</code> in a generalized Schur form,  contains <code>nfu</code> fixed (unobservable) finite eigenvalues of <code>A-λE</code>, <code>Aia-λEia</code>, with <code>Aia</code> upper triangular and invertible and <code>Eia</code> upper triangular and nilpotent, contains <code>nia</code> assigned infinite generalized eigenvalues;  <code>Aig-λEig</code>, with <code>Aig</code> upper triangular and invertible and <code>Eig</code> upper triangular and nilpotent, contains the <code>ninf</code> infinite eigenvalues of <code>A-λE</code>.  The matrices <code>Acl</code>, <code>Ecl</code>, <code>Q</code>, <code>Z</code> and the vectors <code>α</code> and <code>β</code> such that <code>α./β</code> are the generalized eigenvalues of  the pair <code>(Acl,Ecl)</code> are returned in the <code>GeneralizeSchur</code> object <code>Scl</code>.  The values of <code>nfu</code>, <code>nia</code> and <code>ninf</code> and are returned in the 3-dimensional vector <code>blkdims = [nfu, nia, ninf]</code>.</p><p>Method:  For a general pair <code>(A-λE,C)</code> the dual of the modified generalized Schur method of [1] is used to determine <code>K</code> and <code>L</code> such that the pair <code>(A+K*C,E+L*G)</code> has only infinite eigenvalues.</p><p>References:</p><p>[1] A. Varga.      On stabilization methods of descriptor systems.     Systems &amp; Control Letters, vol. 24, pp.133-138, 1995.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixPencils.jl/blob/315e583cb9aa132ee009c727c1e0948d67c74156/src/gsfstab.jl#L761-L805">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixPencils._qrE!" href="#MatrixPencils._qrE!"><code>MatrixPencils._qrE!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_qrE!(A, E, Q, B; withQ = true)</code></pre><p>Reduce the regular matrix pencil <code>A - λE</code> to an equivalent form <code>A1 - λE1 = Q1&#39;*(A - λE)</code> using an orthogonal or unitary transformation matrix <code>Q1</code> such that the transformed matrix <code>E1</code> is upper triangular. The reduction is performed using the QR-decomposition of E.</p><p>The performed left orthogonal or unitary transformations Q1 are accumulated in the matrix <code>Q &lt;- Q*Q1</code>  if <code>withQ = true</code>. Otherwise, <code>Q</code> is unchanged.   </p><p><code>Q1&#39;*B</code> is returned in <code>B</code> unless <code>B = missing</code>.              </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixPencils.jl/blob/315e583cb9aa132ee009c727c1e0948d67c74156/src/regtools.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixPencils._svdlikeAE!" href="#MatrixPencils._svdlikeAE!"><code>MatrixPencils._svdlikeAE!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_svdlikeAE!(A, E, Q, Z, B, C; svdA = true, fast = true, atol1 = 0, atol2 = 0, rtol, withQ = true, withZ = true) -&gt; (rE, rA22)</code></pre><p>Reduce the regular matrix pencil <code>A - λE</code> to an equivalent form <code>A1 - λE1 = Q1&#39;*(A - λE)*Z1</code> using  orthogonal or unitary transformation matrices <code>Q1</code> and <code>Z1</code> such that the transformed matrices <code>A1</code> and <code>E1</code>  are, for <code>svdA = true</code>, in the following SVD-like coordinate form</p><pre><code class="nohighlight hljs">               | A11-λE11 |  A12  |  A13  |
               |----------|-------|-------|
    A1 - λE1 = |    A21   |  A22  |   0   | ,
               |----------|-------|-------|
               |    A31   |   0   |   0   |</code></pre><p>where the <code>rE x rE</code> matrix <code>E11</code> and <code>rA22 x rA22</code> matrix <code>A22</code> are nosingular, and <code>E11</code> and <code>A22</code> are upper triangular,  if <code>fast = true</code>, and diagonal, if <code>fast = false</code>. </p><p>If <code>svdA = false</code>, only <code>E</code> is reduced to SVD-like form and <code>A1 - λE1</code> has the form</p><pre><code class="nohighlight hljs">               | A11-λE11 |  A12  |
    A1 - λE1 = |----------|-------| , 
               |    A21   |  A22  |</code></pre><p>where the <code>rE x rE</code> matrix <code>E11</code> is nonsingular upper triangular, if <code>fast = true</code>,  and diagonal, if <code>fast = false</code>, and <code>A22</code> is unreduced and has rank <code>rA22</code>.</p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively, the absolute tolerance for the  nonzero elements of <code>A</code>, the absolute tolerance for the nonzero elements of <code>E</code>,  and the relative tolerance  for the nonzero elements of <code>A</code> and <code>E</code>. </p><p>The reduction is performed using rank decisions based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.</p><p>The performed left orthogonal or unitary transformations Q1 are accumulated in the matrix <code>Q &lt;- Q*Q1</code>  if <code>withQ = true</code>. Otherwise, <code>Q</code> is unchanged.    The performed right orthogonal or unitary transformations Z1 are accumulated in the matrix <code>Z &lt;- Z*Z1</code> if <code>withZ = true</code>.  Otherwise, <code>Z</code> is unchanged.  </p><p><code>Q1&#39;*B</code> is returned in <code>B</code> unless <code>B = missing</code> and <code>C*Z1</code> is returned in <code>C</code> unless <code>C = missing</code> .              </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/MatrixPencils.jl/blob/315e583cb9aa132ee009c727c1e0948d67c74156/src/regtools.jl#L29-L68">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="sklfapps.html">« Some applications of structured matrix pencil computations</a><a class="docs-footer-nextpage" href="lstools.html">Manipulation of linearizations of polynomial or rational matrices »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.0 on <span class="colophon-date" title="Monday 12 May 2025 09:30">Monday 12 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
